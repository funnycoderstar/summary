##  重排和重绘
1. 处理HTML标记并构建DOM树
2. 处理CSS标记并构建CSSOM树
3. 将DOM和CSSOM合并成一个渲染树（这里需要注意一下，有了渲染树，开始进入“布局”阶段；到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在视口在确切位置）
4. 根据渲染树来布局，以计算每个节点的几何信息（为了弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始遍历）
5. 将各个节点绘制到屏幕上。

第一步到第三部非常快，耗时的是第四步和第五步

"生成布局"（flow）和 "绘制"（paint) 这两步，合称为"渲染"（render);

网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染；
一下三种情况会导致网页重新渲染
1.修改DOM
2.修改样式表
3.用户事件（比如鼠标悬停，页面滚动，输入框键入文字， 改变窗口大小等）

“重绘”不一定需要“重排”，比如改变某个网页的颜色，就只会触发“重绘”，不会触发“重排”，因为布局没有改变；
”重排“必然导致”重绘“，比如改变改变一个网页元素的位置，就会同时触发”重排“和”重排“，因为布局改变了；

# 对性能的影响
一般规则是
- 样式表越简单，重排和重绘就越快
- 重排和重绘的DOM元素层级越高，成本就越高
- table元素的重排和重绘成本，要高于div元素

# 提高性能的几个技巧

1.DOM的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作
2.如果某个样式是通过重排得到的，那么最好缓存结果， 避免下一次用到的时候，浏览器又要重排
3.不要一条一条的改变样式，而是要通过改变class, 或者csstext属性， 一次性改变样式