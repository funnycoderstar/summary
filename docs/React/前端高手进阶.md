## 22.如何合理搭建前端项目？
### 项目组织

multirepo
将项目中的模块拆分出来，放在不同的仓库中进行独立管理。
存在一些问题：
- 开发调试及版本更新效率低下。
- 团队技术选型分散。
monorepo
将所有相关的模块放在同一个项目仓库中。这种方式在管理上会更加方便，项目所有代码可以使用统一的规范及构建、测试、发布流程。
`lerna` 是一个用于管理带有多个包的 JavaScript 项目工具，用 lerna 管理的项目会有 3 个文件目录：packages 目录、learna.json 文件和 package.json 文件。通过 lerna 命令行工具在初始化项目的时候就可以创建它们。

### 代码规范
编写规范：
3个核心原则
- 可执行：编写规范中的每一条规则都能有对应的校验工具规则与之对应
- 可配置：代码可读性是一个比较主观的问题，比如有人主张2空格缩进，有人主张4空格缩进，使用更具丰富配置项的代码校验工具就可以很轻松地解决这些分歧。
- 可扩展：这一点也是对于校验工具的要求，即当校验工具的已有配置规则无法支持项目需求时，可以自行编写插件来扩展校验规则。

Eslint
满足可配置、可扩展的原则。它的核心功能是通过一个叫 verify() 的函数来实现的，该函数有两个必传参数：要验证的源码文本和一个配置对象（通过准备好的配置文件加命令行操作会生成配置）。该函数首先使用解析器生成抽象语法树（AST），同时为规则中所有的选择器添加监听事件，在触发时执行；然后从上到下遍历 AST。在每个节点触发与该节点类型同名的一个事件（即 “Identifier”“WithStatement” 等），监听函数校验完相关的代码之后把不符合规则的问题推送到 lintingProblems 数组中返回。

提交规范
良好的提交规范和编写规范一样，也能较大地提升代码的可维护性。
一方面能保证在代码回退时能快速找到对应的提交记录，另一方面也可以直接将提交消息生成修改日志（Change Log）
推荐使用工具 [@commitlint/cli](https://commitlint.js.org/#/) 和 [husky](https://www.npmjs.com/package/husky)。commitlint 可以设置提交消息模板并校验，而 husky 可以设置 pre-commit 钩子，在提交代码时调用 commitlint 进行强制校验，避免生成不符合规范的提交消息。

使用指南：[编写优雅的 commit message 并自动生成 changelog](https://github.com/yinxin630/blog/issues/26)

随着项目不断增大，对整个项目上运行 lint 或 test 会变得非常耗时，我们一般只想对更改的文件进行检查，这时候可以借助 [lint-staged](https://www.npmjs.com/package/lint-staged)。




## 23.谈性能优化到底在谈什么？
### 性能指标
性能是指程序的运行速度，而前端性能是指页面的响应速度，提到速度必然离不开一个变量，那就是时间。所以我们会看到性能指标都是以时间为单位来测量的。
从是否可以通过浏览器采集上报，是否由权威组织或大型公司提出，以及是否严重影响用户体验这 3 个方面考虑，选取了下面一些重要的指标。
#### 首屏绘制（First Paint，FP）
首屏绘制时间是指从开始加载到浏览器首次绘制像素到屏幕上的时间。也就是页面在屏幕上的时间。页面在屏幕上首次发生视觉变化的时间。
注意首屏绘制不包括默认的背景绘制，但包括非默认的背景绘制。由于首次绘制之前网页呈现默认背景白色，所以也俗称“白屏时间”。
 performance.getEntriesByType() 
#### 首屏内容绘制（First Contentful Paint，FCP）
浏览器首次绘制来自 DOM 的内容时间，这个内容可以是文字、图片（也包括背景图片）、非空白的 canvas 和 svg。
#### 可交互时间（Time to Interactive，TTI）
是指网页在视觉上都已渲染出了，浏览器可以响应用户的操作了。

#### 总阻塞时间（Total Blocking Time，TBT）
阻塞用户响应（比如键盘输入、鼠标点击）的所有时间。
#### 最大内容绘制（Largest Contentful Paint，LCP)
最大内容绘画指的是视口内可见的最大图像或文本块的绘制时间。测量这个指标的值和 TBT 相似，不同的是将实体类型改为“largest-contentful-paint”。
### 统计方式
平均值统计：
百分位数统计：
### 优化思路
加载性能优化和渲染性能优化。

相关文章：
- [解读新一代 Web 性能体验和质量指标](https://juejin.im/post/6844904168591736846)

## 30. 前端热点技术之 serverless
### 什么是 Serverless
开发者不用考虑服务器环境搭建和维护等问题，只需要专注于开发。
Serverless一种构建和管理基于微服务架构的完整流程，允许在服务部署级别而不是在服务器部署级别来管理你的应用部署。与传统架构的不同之处在于，它完全由云厂商管理，由事件触发，以无状态的方式运行（可能只存在于一次调用的过程中）在容器内。
### Serverless 的组成
Serverless 架构由两部分组成，Fass和 Bass
- Fass(Function-as-a-Service) 函数即服务，一个函数就是一个服务，函数可以由任何语言编写，除此之外不需要关心任何运维细节，比如计算资源、弹性扩容，而且还可以按量计费，且支持事件驱动。
- BaaS（Backend-as-a-Service）后端即服务，集成了许多中间件技术，比如数据即服务（数据库服务）、缓存、网关等。

### Serverless 的特点
- 免维护
- 费用
- 深度绑定
- 深度绑定
- 深度绑定

### 一个简单的例子
以阿里云的函数计算为例，可以分为两类：事件函数和 HTTP 函数。

要实现的功能：当 GitHub 仓库中的某个分支有新的提交时，拉取最新代码并编译，然后将编译生成的代码部署到 OSS 存储的静态服务器上。

拉取仓库代码、安装依赖并构建、将生成的代码上传部署。

#### 拉取代码
首先身份认证问题。由于是私有仓库，所以只能通过密钥文件或账号密码的形式来认证访问权限。如果通过账号密码的形式登录，则要模拟键终端交互，这个相对而言实现成本较高，所以采用了配置 ssh key 的方式。具体是根据前面传入的配置信息找到私钥文件所在地址并下载到本地，但是因为权限问题，并不能直接保存到当前用户的 .ssh 目录下。
另一个问题是在首次进行 git clone 操作的时候，终端会出现一个是否添加 known hosts 的提示，在终端中操作的时候需要键盘输入 “Y” 或者 “N” 来继续后面的操作。这里可以通过一个选项本来关闭这个提示。
#### 安装依赖并构建
执行 package.json 文件中配置的脚本任务即可
#### 将生成的代码上传部署
最后上传部署可以根据不同的场景编写不同的模块，比如有的可能部署在 OSS 存储上，会需要调用 OSS 对应的 SDK 进行上传，有的可能部署在某台服务器上，需要通过 scp 命令来传输。

## 31.微前端与功能的可重用性
在日常开发中是怎么复用代码的？
- 复制粘贴：增加了很多重复的代码，复用代码逻辑发生变动时需要处处修改
- 封装模块：不适用于多个项目要使用同一个模块
- 打包成库：模块很好地解决了跨文件复用代码的问题，对于跨项目复用的情况可以通过打包成库的方式来解决
- 提供服务：库这种复用方式其实也有缺陷，首先库有特定的依赖，比如要在 React 项目使用基于 Vue 开发的树形组件，就必须把 Vue 也引进来，这样势必会增加项目体积和复杂度；其次库更多的是偏向功能的复用，而偏向业务的代码则很少用库来实现。如果使用微前端架构就可以按照业务拆分成微应用，然后再通过配置引用的方式来复用所需的微应用。

不过微前端最早被提出不是为了代码的复用，而是用来将项目进行拆分和解耦。
微前端：它将后端的微服务概念扩展到了前端世界。微服务是服务端提出的一个有界上下文、松耦合的架构模式，具体是将应用的服务端拆分成更小的微服务，这些微服务都能独立运行，采用轻量级的通信方式（比如 HTTP ）

微前端、微服务这些架构模式的演变趋势就是不断地将逻辑进行拆分，从而降低项目复杂度，提升可维护性和可复用性。

### 微前端应用场景
- 公司内部的平台系统。
- 大型单页应用。
- 对已有系统的兼容和扩展

### 微前端核心思想
- 技术无关
- 环境独立
- 原生优先
### 微前端架构模式
#### 服务端集成

#### 浏览器集成
浏览器集成也称运行时集成
- iframe
- 前端路由
- Web Components

这也是一种非常热门的集成方式，代表性的框架有 [single-spa](https://github.com/single-spa/single-spa) 以及基于它修改的[乾坤](https://github.com/umijs/qiankun)。

## 问题记录
- 想法太多，但是行动很少，比如想学些serverless,微前端，webpack5，可视化搭建等等，做一个的时候还在想另一个，人的精力是有限的，所以要把想做的是分一下类，紧急重要，xx,然后分成几个番茄钟去行动，去一个个完成，而不要想着一天，一周，就能把所有的知识装进自己的脑袋中。

